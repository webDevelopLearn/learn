**函数是对象，函数名是指向函数对象的指针。**

**所以函数名不会绑定某个函数。**

# 定义函数

有三种方法:

通过函数声明语法。
```
function 函数名 (参数1,参数2...){
    ...（函数体）
}
```
通过函数字面量（函数表达式）。

```
var 函数名 = function(参数1,参数2){
    ...（函数体）
}
```

通过Function构造函数。前面的所有参数都是新函数对象的参数，最后一个参数视为函数体。不推荐这种方法。
```
var 函数名 = new Function("参数1","参数2","参数3"...);
```

# 函数声明提升

在执行任何代码之前，解析器会首先读取所有声明，包括变量声明，函数声明。

所以以下代码，两种对函数不同的定义方法会导致不同的结果。
```
alert(sum(5,10));
function sum (num1,num2){
    return num1 + num2;
}   //这样写不会有错，因为解析器先扫描了函数声明再执行第一行代码。

alert(sum(5,10));
var sum = function(num1,num2){
    return num1 + num2;
}  //这样写会出错。因为解析器只扫描到变量sum的声明和sum()，而函数此时还未保存在变量sum中。自然地，在执行第一行的时候，就会发生标识符undefined的错误。
```

# 函数的返回值

【语法】
```
return 表达式;
```
return语句用于返回调用函数后的返回值。只能用于函数体内。

如果没有return语句，就返回undefined。

当只有一个return关键字的时候，返回undefined。

当执行到return语句时，return语句后面的语句都不再执行。finally语句除外。

>return语句和表达式之间不能换行，除非在return后加上花括号。

# 函数的作用域

指的是变量的作用范围。分为局部变量和全局变量。

**局部变量**：在函数内部的变量只作用于这个函数。也就是说，只能在函数内部用。等同“私有变量”。

**全局变量**：而在函数外部的变量就是全局变量，作用于全局。函数内部可以引用全局变量。

当函数内部的变量和全局变量同名时，函数内部的变量会覆盖全局变量，但全局变量在其他地方仍然有效。

>【关于var】
除了在函数内部使用var声明变量时是局部变量之外，在其他区块使用var都是全局变量。



---

# 函数的内部属性

### name

返回紧跟function关键字后的函数名。

对于匿名函数，返回空字符串；

对于函数表达式定义的函数，返回function后面的函数名，但真正的函数名还是紧跟var后面的。

### length

返回传入的参数个数。

### arguments

保存函数传入的所有参数。

##### length属性

传入的参数个数

##### caller属性
返回它对应的原函数，可以用于调用自身。但在ES5后，使用它在严格模式下会出错，在非严格模式下为undefined。


# 闭包

---
## 基本类型和引用类型的变量区别

在JavaScript中，所有函数的参数都是按值传递的。而访问变量有两种，分别是基本类型和引用类型。

基本类型的变量的值存放在栈内存中，引用类型的变量的值存放在堆内存当中。



当复制一个变量时，基本类型的变量就会在栈内存上创建一个新的值，并把这个值放在新复制的变量位置上。而这两个变量是独立的，互不影响。

例如：
```
var num1 = 50;
var num2 = num1;
```
在栈内存上的表现：

![0047](/screenshots/0047.jpg)


而引用类型的变量则是复制了一个指针，使这两个变量都指向堆内存上的一个对象的地址。所以当改变其中一个变量时，另一个也会受到影响。

例如：
```
var obj1 = new Object();
var obj2 = obj1;
obj1.name = "Ben";
obj2.name;  //输出是"Ben"
```

在堆内存上的表现：

![0048](/screenshots/0048.jpg)

---
## 所有函数的参数都是按值传递的

如题。包括引用类型的值，也是按值传递，不是用按引用的方式。

故，在向函数的参数传递一个引用类型的值时，会把这个引用类型的对象在堆内存中的地址复制给这个参数（局部变量），所以这个参数（局部变量）的变化会反映在函数外部。

按引用和按值的不同之处在于，如果函数内部有同名的对象和其属性，当修改对象的属性时，那么如果按引用的话，向传递的引用类型对象也会再次指向新的属性，但按值传递的话不会。

例如：
```
var cat = new Object();
function animal(obj){
    obj.name = "Kitty";
    obj = new Object();
    obj.name = "Dora";
}
animal(cat);
cat.name;  //输出是"Kitty"。
```
在内存上的表现：

![0049](/screenshots/0049.jpg)

---
## 执行环境和作用域链

执行环境代表了变量或者函数有权访问的一个范围。每个执行环境都有一个变量对象，保存了这个对象所有的变量和函数。

每个函数都有自己的一个执行环境。

而最外层的一个执行环境是全局执行环境，一般认为是window对象。

当一个执行环境内的代码被执行时，其变量对象就会创建一个作用域链，并通过这条作用域链有序的访问所有变量和函数。由内向外访问。解析标识符就是沿着作用域链一级一级向外搜索标识符。如果到达最外层的全局执行环境仍然搜索不到标识符，就会报错。

作用域链只能向上搜索，不能向下搜索。也就是说，外部环境不能访问内部环境的任何变量和函数。

在作用域链中，外部函数的变量对象始终处于第二位，以此类推，最后是全局执行环境。也就是说，当解析器查找变量时，总是会从作用域链中的第一个对象找变量，找到就直接使用，找不到就继续向外找，直到找到为止，如果到全局执行环境仍没有找到的话就报错。

观察下面代码：

```
var age = 17;
function animal(){
    var height = 15;
    function cat(){
        var weight = 20;
        height = age;
        age = weight;
    }
    cat();
}
animal();    
```

![0049](/screenshots/0050.jpg)

但是问题来了，外部函数无法访问内部函数，如果想访问内部函数的变量，那要怎么办呢？

**答案是使用闭包的方法。**

闭包的意思就是，把一个内部函数作为返回值，那么外部函数就能够读取它的内部变量了。换句话说，能够读取其它函数内部变量的函数，就是闭包。


>外层函数每次运行，都会生成一个新的闭包，而这个闭包又会保留外层函数的内部变量，所以内存消耗很大。因此不能滥用闭包，否则会造成网页的性能问题。
